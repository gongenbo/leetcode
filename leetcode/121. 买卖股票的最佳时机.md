dp动态规划  O(n)  O(n)
not ac
```
public int maxProfit(int[] prices) {
    int maxProfit = 0;
    int len = prices.length;
    if(len <2) return maxProfit;
    int[] dp = new int[len];
    dp[0] = 0;
    dp[1] = Math.max(0, prices[1] - prices[0]);
    int minPrices = prices[0] < prices[1]?prices[0]:prices[1];
    for(int i = 2; i < len; i++){
        dp[i] = Math.max(prices[i]-minPrices,dp[i-1]);
        minPrices = Math.min(prices[i],minPrices);
    }
    return dp[len-1];
}
```
一层循环  O(n)  O(1)
```java

//最多一笔交易
    public int maxProfit(int[] prices) {
        int max = 0;
        if(prices.length <=1) return 0;
        int min = prices[0];
        for(int i = 1;i < prices.length;i++){
            max = Math.max(prices[i] - min, max);
            min = Math.min(min,prices[i]);
        }
        return max;
    }
```
c++版
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int maxProfit = 0, minPrice = INT_MAX;
        for(auto price:prices){
            maxProfit = max(maxProfit, price - minPrice);
            minPrice = min(minPrice, price);
        }
        return maxProfit;
    }
};
```