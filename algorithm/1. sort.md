# 题目
[](https://www.cnblogs.com/xiaohuiduan/p/11188304.html)
```
选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法;
而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法
```

# 快排
```java
package sort;

import java.util.Arrays;

public class QuickSort {

    public void sort(int[] nums,int lo,int hi){
        if(lo>= hi)return; // 判断是否只剩下一个元素，是，则直接返回
        // 利用 partition 函数找到一个随机的基准点
	    int p = partition(nums,lo,hi);
        // 递归地对基准点左半边和右半边的数进行排序
        sort(nums,lo,p-1);
        sort(nums,p+1,hi);
    }
    int partition(int[] nums, int lo, int hi){
        // 随机选择一个数作为基准值，nums[hi] 就是基准值(这里把lo作为基准放到high)
        swap(nums,lo,hi);
        int i,j;

        // 从左到右用每个数和基准值比较，若比基准值小，则放到指针 i 所指向的位置。循环完毕后，i 指针之前的数都比基准值小
        for(i=lo,j=lo;j<hi;j++){
            if(nums[j]<=nums[hi]){
                swap(nums,i++,j);
            }
        }

        // 末尾的基准值放置到指针 i 的位置，i 指针之后的数都比基准值大
        swap(nums,i,j);

        // 返回指针 i，作为基准点的位置
        return i;
    }
    public void swap(int[] nums,int i,int j){
        if(i==j){
            return;
        }
        nums[i]=nums[i]^nums[j]; //c=a^b
        nums[j]=nums[i]^nums[j]; //a=c^b
        nums[i]=nums[i]^nums[j]; //b=c^a
    }

    public static void main(String[] args) {
        int a[] = { 3, 1, 2 };
        QuickSort q=new QuickSort();
        q.sort(a, 0, a.length - 1);
        System.out.println("排序结果：" + Arrays.toString(a));
    }
}
```

# 归并排序
```java
class Solution {
    //25
    public int[] sortArray(int[] nums) {
        mergeSort(nums, 0, nums.length-1);
        return nums;
    }
    public void mergeSort(int[] nums,int lo, int hi){
        if(lo >= hi) return;
        int mid = lo + (hi - lo)/2;
        mergeSort(nums, lo, mid);
        mergeSort(nums, mid + 1, hi);
        merge(nums, lo, mid, hi);
    }
    public void merge(int[] nums,int lo, int mid, int hi){
        int i = lo, j = mid+1, k = lo;
        int[] copy = nums.clone();
        while(k <= hi){
            if(j>hi){
                nums[k++] = copy[i++];
            }else if(i>mid){
                nums[k++] = copy[j++];
            }else if(copy[i] < copy[j]){//注意这里是copy
                nums[k++] = copy[i++];
            }else{
                nums[k++] = copy[j++];
            }
        }

    }
    public void swap(int[] nums, int i, int j){
        if(i == j)  return;
         nums[i] = nums[i] ^ nums[j];
         nums[j] = nums[i] ^ nums[j];
         nums[i] = nums[i] ^ nums[j];
    }
    
}
```
# 选择排序
```java
public class BubbleSort {
    public void sort(int[] nums){
        for(int i = 0; i < nums.length-1; i++){
            for(int j = i; j < nums.length; j++){
                if(nums[i]>nums[j]){
                    swap(nums, i, j);
                }
            }
        }
    }
    public void swap(int[] nums, int i, int j){
        if(i == j)  return;
        nums[i] = nums[i] ^ nums[j];
        nums[j] = nums[i] ^ nums[j];
        nums[i] = nums[i] ^ nums[j];
    }
    public static void main(String[] args) {
        int a[] = { 3, 1, 2 };
        BubbleSort q=new BubbleSort();
        q.sort(a);
        System.out.println("排序结果：" + Arrays.toString(a));
    }
}
```
# 自带的排序

从小到大排序

```java
int[][] pairs = [[1,2], [2,3], [3,4]];
Arrays.sort(pairs, (a, b) -> a[0] - b[0]);
for(int[] item:pairs){
    System.out.println(item[0]+" "+item[1]);
}
```

# 冒泡排序
```java
public class BubbleSort {
public static void main(String[] args) {
    int[] arr = new int[] { 2, 8, 7, 9, 4, 1, 5, 0 };
    bubbleSort(arr);
}
public static void bubbleSort(int[] nums){
    for (int i = 1; i < nums.length; i++) {
        // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。
        boolean flag = true;

        for (int j = 0; j < nums.length - i; j++) {
            if (nums[j] > nums[j + 1]) {
                swap(nums, j,j+1);
                flag = false;
            }
        }
        if (flag) {
            break;
        }
    }
}
}
```