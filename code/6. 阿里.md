# 1. 序列和
```
题目描述
给出一个正整数N和长度L，找出一段长度大于等于L的连续非负整数，他们的和恰好为N。答案可能有多个，我我们需要找出长度最小的那个。
例如 N = 18 L = 2：
5 + 6 + 7 = 18
3 + 4 + 5 + 6 = 18
都是满足要求的，但是我们输出更短的 5 6 7
```
```
package ali;
import java.util.Scanner;
public class Sequence {
    public static int display(int N,int L){
        for(int i=L;i<101;i++) {
            if((2*N-i*(i-1))%(2*i)==0&&(2*N-i*(i-1))/(2*i)>=0) {
                int a1=(2*N-i*(i-1))/(2*i);
                for(int j=0;j<i-1;j++) {
                    System.out.print(a1+j+" ");
                }
                System.out.print(a1+(i-1));
                return 0;
            }
        }
        System.out.print("No");
        return 0;
    }
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        int N = in.nextInt();
        int L = in.nextInt();
        display(N,L);
    }
}

```
# 3.29笔试
## 1. vote
链接：https://www.nowcoder.com/discuss/627169?type=all&order=time&pos=&page=1&channel=-1&source_id=search_all_nctrack

```
https://www.nowcoder.com/discuss/627252?channel=-1&source_id=discuss_terminal_discuss_history_nctrack&ncTraceId=404983f074a74e1d9a71a1c445802c38.113.16176815608745704
作者：兰坤

小明和我参加班长的选举投票，投票人数为n，每人可以投K票，第一行输入为投票人数，第二行输入为每个人投给小明的票数求保证我能获胜最小的K。
例如下面的示例，由于小明获得1+1+1+5+1=9票，则我获得4+4+4+0+4=12票，我获胜，此时5最小。
输入：
5
1 1 1 5 1
输出：
5

输入：
5
2 2 2 3 4
输出：
6
```
```java
import java.util.Scanner;

public class Vote {
    public static int getK(int maxK, int[] other){
        int sumMe = 0;
        for(int i = 0;i< other.length;i++){
            sumMe += maxK - other[i];
        }
        return sumMe;
    }
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        if(n < 1) return;
        int[] other = new int[n];
        int maxK = 0,sumOther = 0;
        for(int i = 0;i < n;i++){
            other[i] = in.nextInt();
            sumOther += other[i];
            maxK = Math.max(maxK,other[i]);
        }
        int sumMe = getK(maxK, other);
        for(int i = maxK;;i++){
            if(sumMe > sumOther){
                System.out.println(i);
                break;
            }else{
                sumMe += n;
            }
        }
    }
}
```

## 2. 最少的车站

leetcode原题：1334. 阈值距离内邻居最少的城市 floyd算法。
```
作者：兰坤
链接：https://www.nowcoder.com/discuss/627252?channel=-1&source_id=discuss_terminal_discuss_history_nctrack&ncTraceId=404983f074a74e1d9a71a1c445802c38.113.16176815608745704
来源：牛客网

要求n各城市中有m条道路，求在距离d以内，从一个城市到其它城市的数量最少，如遇到数量相同，则选择输出编号最大的那个城市。
第一行，测试数据的组数：t组
第二行：n（城市数量） m（道路条数） d（要求距离）
接下来m行：l（城市编号） r（城市编号） w（距离）
例如：
输入：
1
4 4 4
0 1 3
1 2 1
2 3 1
1 3 4
输出：
3
```

```java

```